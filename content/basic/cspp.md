---
title: 深入理解计算机系统
date: 2016-7-26 13:29
---


[TOC]

# 第一章 #
# 第二章 #
# 第三章 程序的机器级表示 #
## 3.2 程序编码 ##
### 3.2.1 机器级代码 ###
> 概念

- 程序计数器：指示将要执行的下一条指令在存储器的地址
    - IA32中，通常称为`PC`，用`%eip`表示
- 整数寄存器`3.4 访问信息更具体`
    - 数量：8个
    - 大小：32位
    - 作用：
        1. 存储地址（对应C语言指针）
        2. 整数数据
        3. 有的用于存储某些重要的程序状态，其他的临时存储数据
- 条件码寄存器
    - 作用：存储最近执行的算术或逻辑指令的状态信息，用于实现控制或条件变化
- 浮点寄存器
    - 作用：存放浮点数据
- 程序存储器`program memory`

> 抽象

1. 机器级程序的格式和行为，定义为指令集体系结构（Instruction set architecture, ISA）

    - 定义了处理器状态
    - 定义了指令的格式
    - 定义了每条指令对状态的影响

2. 机器级程序使用的存储器地址是虚拟地址

### 3.2.2 代码示例 ###

> gcc

- 得到目标文件`gcc -O1 -c hello.c --> heelo.s`
- 得到汇编文件`gcc -O1 -S hello.c --> hello.o`
- 反汇编
    1. 目标文件`objdump -d hello.o`
    2. 可执行程序`objdump -d hello.out`

> 汇编代码语法

- IA32指令长度在1-15个字节，不常用的指令字节数会更多
- 下一条指令的地址是上一条指令地址+上一条指令的字节数
- 反汇编器基于机器代码文件中的字节序列来确定汇编代码
- 反汇编`.o文件`和`.s文件的代码`有区别
    1. 反汇编器的指令名字后面没有`l`，这个后缀是大小指示器
- 反汇编`.o文件`和`可执行程序`区别
    1. `可执行程序`经过了链接，所以左边的地址是具体的。
    2. 全局变量的地址
- 汇编代码中`.`开头的行都是指导汇编器和链接器的命令
- 汇编代码不区分有符号或无符号整数、各种类型的指针、指针和整数

### 3.2.3 关于格式的注解 ###
## 3.3 数据格式 ##

> 概念

- 字节：`8位`
- 字：`word 16位`
- 双字：`double words 32位`
- 四字：`quad words 64位`

> 数据类型表

|C声明|Intel数据类型|汇编代码后缀|大小（字节）|
|:---|:----------:|:--------:|---------:|
|char|字节|b|1|
|short|字|w|2|
|int|双字|l|4|
|long int|双字|l|4|
|long long int|---|---|4|
|char *|双字|l|4|
|float|单精度|s|4|
|double|双精度|l|8|
|long double|扩展精度|t|10/12|

## 3.4 访问信息 ##

> 概念

- 寄存器
    - 前6个可以看成通用寄存器，因为有些指令以固定的寄存器作为源寄存器或目的寄存器
    - 前3个寄存器和中间3个寄存器的保存恢复惯例不同，最后2个寄存器根据栈惯例的标准惯例才能修改
    - 字节操作指令可以读写低8位的寄存器`%al, %ah...`
    - 字操作指令可以读写低16位的寄存器`%ax, %cx...`

|32|16|8|0|
|:-|-:|:-:|:-:|
|%eax|%ax|%ah|%al|
|%ecx|%cx|%ch|%cl|
|%edx|%dx|%dh|%dl|
|%ebx|%bx|%bh|%bl|
|%esi|%si|||
|%edi|%di|||
|%esp|%sp||栈指针|
|%ebp|%bp||帧指针|

### 3.4.1 操作数指示符 ###

>操作数类型，这里还有一个操作数格式的表

- 立即数(immediate)
    - 语法：`$整数`
    - 例子：`$23 | $-23 | $0xFF`

- 寄存器(register)
    - 语法：`Ea表示任意寄存器a & R[Ea]表示该寄存器内的值`
    - 例子1：`%eax --> 得到%eax寄存器内的值`

- 存储器(memory)
    - 语法：`Mb[Addr]`
    - 例子：`(%eax) --> 得到%eax寄存器内的值，这个值应该是个地址，然后根据这个地址找到该地址的值`

### 3.4.2 数据传送指令 ###

> 概念

mov指令在汇编语言中，有2个分类优先级。

我们先根据是做符号扩展还是零扩展或者没有扩展来选择mov指令，然后根据寄存器的位数来选择mov指令的后缀`b:8位 | w:16位 | l:32位`

### 3.4.3 数据传送示例 ###
## 3.5 算术和逻辑操作 ##
### 3.5.1 加载有效地址 ###
> leal指令

这个指令没有变种，就是不需要根据操作数的大小来添加后缀`b | w | l`

格式是：`leal S,D` --> `D <-- &S`

就是把S的地址保存在D中，D必须是一个32位的寄存器才对。

### 3.5.2 一元操作和二元操作 ###

> 一元操作：INC DEC NEG NOT

> 格式：INC D，因为只有一个操作数，所以叫一元

- `INC`：自加1
- `DEC`：自减1
- `NEG`：取负
- `NOT`：取补

> 二元操作：ADD SUB IMUL XOR OR AND

> 格式：ADD S,D 得到 D <-- D+S

> 规则约束

- 第一个操作数可以是：`立即数`、`寄存器`、`存储器地址`
- 第二个操作数可以是：`寄存器`、`存储器地址`

### 3.5.3 移位操作 ###

> 指令：SAL SHL SAR SHR

> 格式：SAL k,D 得到 D <-- D<<k

- `SAL`：左移
- `SHL`：左移
- `SAR`：算术右移
- `SHR`：逻辑右移

> 规则约束

- 参数`k`
    1. 单个字节编码
    2. 因为IA32，所以只能移位0-31位。
    3. 可以是`立即数`、`单字节寄存器中的值%cl`，这个指令很特殊，只允许使用`%cl`这个寄存器作操作数

- 左移适用于有/无符号数

- 右移对有/无符号数做不同的操作

### 3.5.5 特殊的算术操作 ###
> 这节针对的是64位的有/无符号乘法，除法指令。转为四字指令

> 两个32位数的乘法，有/无符号的要求如下

- 要求一个参数必须放在寄存器`%eax`，另一个作为指令的源操作数给出
- 乘积的存放：高32位存放在`%edx`，低32位存放在`%eax`

> 例子：如果计算 x * y，假设都是32位的数，x存放在`%ebp+8`，y在`%ebp+12`

1. movl 12(%ebp), %eax
2. imull 8(%ebp) --> 这个指令会把这个操作数乘%eax的值
3. movl %eax, (%esp) --> 指针指向低32位
4. movl %edx, 4(%esp) --> 指针+4指向高32位

因此，低位的在栈顶，+4找到高32位

> 除法，则`%eax` --> 存放商 `%edx` --> 存放余数

- 无符号除法使用`divl`指令，事先将`%edx`设置为0
- 有符号除法使用`idivl`指令，根据数的符号选择移位操作，将`%edx`置1或置0

## 3.6 控制 ##
### 3.6.1 条件码 ###
> 条件码：描述最近的算术或逻辑操作的属性，可以检查这些条件码寄存器来执行条件分支指令

> 常用条件码

- `CF`：进位标志，最近的操作使最高位产生了进位，`用来检查无符号操作数的溢出`
- `ZF`：零标志，最近的操作得出的结果为0
- `SF`：符号标志，最近的操作得到的结果为负数
- `OF`：溢出标志，最近的操作导致一个补码溢出，正溢出或负溢出

> 导致条件码改变的指令：INC DEC NEG NOT | ADD SUB IMUL XOR OR AND | SAL SHL SAR SHR

> 有两个指令只改变条件码不改变其他寄存器：CMP TEST

- `CMP S2, S1`：比较，操作`S1-S2`，如果两个数相等，则零标志`ZF=1`
- `TEST S2, S1`：测试，操作`S1 & S2`，有一个数是掩码，用来指示哪些位应该被测试

### 3.6.2 访问条件码 ###
> 条件码不会直接读取，常用的读取方法有三种

1. 可以根据条件码的组合，将一个字节设置为0或1，这里使用`SET`系列指令
    - 有符号比较基于`SF^OF和ZF的组合`
    - 无符号比较基于`CF和ZF的组合`
2. 可以条件跳转到程序的某个其他的组合
3. 可以有条件地传送数据

### 3.6.3 跳转指令及其编码 ###
> 跳转指令分为：有条件跳转和无条件跳转

- 有条件跳转：根据条件码寄存器跳转，对应于C语言的if(test-statement)

- 无条件跳转：`根据标号跳转`和`根据地址跳转`
    - 根据标号跳转：`jmp LABEL_NAME` 比如 `jmp L1`
    - 根据地址跳转：`jmp *%eax` 或者 `jmp *(%eax)`


> jmp 地址的计算

1. 获得跳转指令的指令编码的最后一个字节
2. 获得跳转指令下一条指令的地址
3. 将1和2获得的数值相加，则是具体的跳转地址

**注意点**
    1. 1获得指令编码的时候注意该字节的符号
    2. 程序计数器，即PC存储的值是3获得的值，而不是jmp指令的地址


### 3.6.4 翻译条件分支 ###
## 3.7 过程 ##
## 3.8 数组分配和访问 ##
## 3.9 异质的数据结构 ##
## 3.10 综合：理解指针 ##
## 3.11 应用：使用GDB调试器 ##
## 3.12 存储器的越界引用和缓冲区溢出 ##
## 3.13 x86-64：将IA32扩展到64位 ##
## 3.14 浮点程序的机器级表示 ##
## 3.15 小结 ##
