<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/colorful.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>jsp总结 - Fang's Wiki</title>
    <meta name="keywords" content="Linux, Java, Shell"/>
    <meta name="description" content="Personal Wiki"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    
  </head>

  <body>
    <div id="container" class="typo">
      
<div id="header">
  <div id="post-nav">
    <a href="/wiki/">Fang's Wiki</a>
    &nbsp;&#187;&nbsp;
    <a href="/wiki/#jsp">jsp</a>
    &nbsp;&#187;&nbsp;jsp总结
    <span class="updated">Updated&nbsp;
    2016-07-28 22:07
    </span>
  </div>
</div>
<div class="clearfix"></div>
<div id="content">
  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">容器</a></li>
<li><a href="#jsp">JSP</a><ul>
<li><a href="#0x01-jsp">0x01 jsp元素</a></li>
<li><a href="#0x02">0x02 隐式对象对应</a></li>
<li><a href="#0x03">0x03 四大作用域</a></li>
<li><a href="#0x04-el">0x04 EL表达式</a><ul>
<li><a href="#el">EL隐式表达式</a></li>
</ul>
</li>
<li><a href="#0x05">0x05 表达式</a></li>
<li><a href="#0x06-jsp-servlet">0x06 JSP--&gt;Servlet</a></li>
</ul>
</li>
<li><a href="#_2">疑难点</a></li>
</ul>
</div>
<h2 id="_1">容器</h2>
<blockquote>
<p><strong><em>容器的功能</em></strong>：</p>
<ul>
<li>
<p>通信支持</p>
</li>
<li>
<p>声明周期管理</p>
</li>
<li>
<p>多线程支持</p>
</li>
<li>
<p>声明方式实现安全</p>
</li>
<li>
<p>JSP支持</p>
</li>
</ul>
</blockquote>
<p><code>Tomcat</code>就是我们说的容器，可以说它是Apache的加强版，能处理jsp</p>
<h2 id="jsp">JSP</h2>
<h3 id="0x01-jsp">0x01 jsp元素</h3>
<div class="hlcode"><pre><span class="x">1. scriptlet： </span><span class="cp">&lt;%</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">2. 表达式： </span><span class="cp">&lt;%=</span> <span class="cp">%&gt;</span><span class="x"> 不需要分号</span>
<span class="x">3. 指令： </span><span class="cp">&lt;%</span><span class="err">@</span> <span class="err">指令名</span> <span class="cp">%&gt;</span><span class="x"></span>
<span class="x">    page, taglib, include</span>
<span class="x">4. 声明： </span><span class="cp">&lt;%</span><span class="o">!</span> <span class="err">声明变量表达式</span> <span class="cp">%&gt;</span><span class="x"> 这里面声明的变量在servlet方法之外</span>
<span class="x">5. EL表达式： 更好的调用java方法返回一些值</span>
</pre></div>


<h3 id="0x02">0x02 隐式对象对应</h3>
<div class="hlcode"><pre><span class="n">JspWriter</span> <span class="o">--&gt;</span> <span class="n">out</span>
<span class="n">HttpServletRequest</span> <span class="o">--&gt;</span> <span class="n">request</span>
<span class="n">HttpServletResponse</span> <span class="o">--&gt;</span> <span class="n">response</span>
<span class="n">HttpSession</span> <span class="o">--&gt;</span> <span class="n">session</span>
<span class="n">ServletContext</span> <span class="o">--&gt;</span> <span class="n">application</span>
<span class="n">ServletConfig</span> <span class="o">--&gt;</span> <span class="n">config</span>
<span class="n">Throwable</span> <span class="o">--&gt;</span> <span class="n">exception</span>
<span class="n">PageContext</span> <span class="o">--&gt;</span> <span class="n">pageContext</span>
<span class="n">Object</span> <span class="o">--&gt;</span> <span class="n">page</span>
</pre></div>


<h3 id="0x03">0x03 四大作用域</h3>
<div class="hlcode"><pre><span class="n">Page</span>
<span class="n">Request</span>
<span class="n">Session</span>
<span class="n">Application</span>
</pre></div>


<h3 id="0x04-el">0x04 EL表达式</h3>
<h4 id="el">EL隐式表达式</h4>
<ul>
<li>pageScope</li>
<li>requestScope</li>
<li>sessionScope</li>
<li>applicationScope</li>
<li>param</li>
<li>paramValues</li>
<li>header</li>
<li>headerValues</li>
<li>cookie</li>
<li>initParam</li>
<li>pageContext(it's a javabean)</li>
</ul>
<div class="hlcode"><pre><span class="c1">// 使用EL表达式调用函数</span>
<span class="c1">// 1. 编写.java文件，里面写你需要调用的函数，要static的才行</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">ElUse</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="n">String</span> <span class="nf">say</span><span class="o">(){</span>
        <span class="k">return</span> <span class="s">&quot;Hello World&quot;</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
<span class="c1">// 2. 编写tld文件</span>
<span class="o">&lt;</span><span class="n">uri</span><span class="o">&gt;</span><span class="n">SayFunction</span><span class="o">&lt;/</span><span class="n">uri</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">function</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="n">myel</span><span class="o">&lt;/</span><span class="n">name</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">function</span><span class="o">-</span><span class="n">class</span><span class="o">&gt;</span><span class="n">com</span><span class="o">.</span><span class="na">fang</span><span class="o">.</span><span class="na">el</span><span class="o">.</span><span class="na">ElUse</span><span class="o">&lt;/</span><span class="n">function</span><span class="o">-</span><span class="n">class</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">function</span><span class="o">-</span><span class="n">signature</span><span class="o">&gt;</span><span class="n">java</span><span class="o">.</span><span class="na">lang</span><span class="o">.</span><span class="na">String</span> <span class="n">say</span><span class="o">()&lt;/</span><span class="n">function</span><span class="o">-</span><span class="n">signature</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">function</span><span class="o">&gt;</span>
<span class="c1">// 3. 在jsp文件写指令</span>
<span class="o">&lt;%</span><span class="err">@</span> <span class="n">taglib</span> <span class="n">prefix</span><span class="o">=</span><span class="s">&quot;test&quot;</span> <span class="n">uri</span><span class="o">=</span><span class="s">&quot;SayFunction&quot;</span> <span class="o">%&gt;</span>
<span class="c1">// 4. 使用</span>
<span class="n">$</span><span class="o">{</span><span class="nl">test:</span><span class="n">say</span><span class="o">()}</span>
</pre></div>


<h3 id="0x05">0x05 表达式</h3>
<div class="hlcode"><pre><span class="o">&lt;%=</span><span class="n">Class</span><span class="o">.</span><span class="na">getInt</span><span class="o">()%&gt;</span> <span class="err">不需要加分号</span>
<span class="c1">// 上一行代码会转换为</span>
<span class="n">out</span><span class="o">.</span><span class="na">print</span><span class="o">(</span><span class="n">CLass</span><span class="o">.</span><span class="na">getInt</span><span class="o">());</span>
</pre></div>


<h3 id="0x06-jsp-servlet">0x06 JSP--&gt;Servlet</h3>
<p>容器会把JSP页面内的每一行html语言放在out.print()中，而java语句则不变</p>
<p>jsp其实也是一个servlet，容器会帮你做一些转变</p>
<h2 id="_2">疑难点</h2>
<ul>
<li><code>getServerPort()</code>&amp;<code>getLocalPort()</code>&amp;<code>getRemotePort()</code></li>
</ul>
<div class="hlcode"><pre><span class="n">getRemotePort</span><span class="o">()</span><span class="err">：得到远程客户的端口，就是发出请求的客户端口</span>
<span class="n">getServerPort</span><span class="o">()</span><span class="err">：请求原来发送到哪个端口</span>
<span class="n">getLocalPort</span><span class="o">()</span><span class="err">：请求最后发送到哪个端口</span>

<span class="err">尽管请求要发送到端口，但是服务器会为每一个线程开一个不同的本地端口，这样一个用户就能同时处理多个用户</span>

<span class="n">PS</span><span class="err">：所以个人判断</span><span class="n">getServerPort</span><span class="o">()</span><span class="err">得到的是访问服务器的端口，而</span><span class="n">getLocalPort</span><span class="o">()</span><span class="err">则是该请求在服务器本地开的端口号</span>
</pre></div>


<ul>
<li>幂等不非幂等</li>
</ul>
<div class="hlcode"><pre><span class="err">幂等：多次运行不会对服务器产生副作用，如</span><span class="n">GET</span>
<span class="err">非幂等：请求若多次发送，能较好处理该问题，如</span><span class="n">POST</span>

<span class="err">买书问题，因为</span><span class="n">POST</span><span class="err">是非幂等，若是网页没有反应，则用户可能多次提交表单造成订单的重复</span>
</pre></div>


<ul>
<li><code>sendRedirect()</code>和<code>getRequestDispatcher()</code></li>
</ul>
<div class="hlcode"><pre><span class="n">sendRedirect</span><span class="o">()</span><span class="err">直接将请求转移到另一个页面，那么这个</span><span class="n">servlet</span><span class="err">获得这个请求之后不要对</span><span class="n">resp</span><span class="err">或者</span><span class="n">req</span><span class="err">做更改（标记，我也不知道这么说对不对）。就算有更改在另一个页面也无法获得更改。</span>

<span class="err">不能对请求做响应的操作，一旦响应，则请求结束</span>

<span class="err">通过</span><span class="n">getRequestDispatcher</span><span class="o">().</span><span class="na">forward</span><span class="o">(</span><span class="n">req</span><span class="o">,</span> <span class="n">resp</span><span class="o">)</span><span class="err">，这样能够让</span><span class="n">req</span><span class="err">或者</span><span class="n">resp</span><span class="err">做些更改再转移到另一个页面</span>
</pre></div>


<ul>
<li>ServeletConfig问题</li>
</ul>
<div class="hlcode"><pre><span class="n">ServletConfig</span><span class="err">针对</span><span class="n">servlet</span>
<span class="o">&lt;</span><span class="n">servlet</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">servlet</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span><span class="n">login</span><span class="o">&lt;/</span><span class="n">servlet</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">servlet</span><span class="o">-</span><span class="n">class</span><span class="o">&gt;</span><span class="n">LoginServlet</span><span class="o">&lt;/</span><span class="n">servlet</span><span class="o">-</span><span class="n">class</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">init</span><span class="o">-</span><span class="n">param</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="n">param</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span><span class="n">name</span><span class="o">&lt;/</span><span class="n">param</span><span class="o">-</span><span class="n">name</span><span class="o">&gt;</span>
            <span class="o">&lt;</span><span class="n">param</span><span class="o">-</span><span class="n">value</span><span class="o">&gt;</span><span class="n">test</span><span class="o">&lt;/</span><span class="n">param</span><span class="o">-</span><span class="n">value</span><span class="o">&gt;</span>
        <span class="o">&lt;/</span><span class="n">init</span><span class="o">-</span><span class="n">param</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">servlet</span><span class="o">&gt;</span>
<span class="err">这里配置的参数只对</span><span class="n">LoginServlet</span><span class="err">有用，其他</span><span class="n">servlet</span><span class="err">或者</span><span class="n">jsp</span><span class="err">要先把键值对设置在请求中，然后转发请求</span>

<span class="n">ServletConfig</span><span class="err">是作为参数在容器初始化</span><span class="n">servlet</span><span class="err">之后调用</span><span class="n">init</span><span class="o">(</span><span class="n">ServletConfig</span> <span class="n">config</span><span class="o">)</span><span class="err">的时候才给的</span>
<span class="err">所以最好不要在</span><span class="n">init</span><span class="err">里面调用</span><span class="n">getServeletConfig</span><span class="o">()</span><span class="err">方法</span>

<span class="err">容器在部署的时候只初始化一次，所以只读一次</span><span class="n">web</span><span class="o">.</span><span class="na">xml</span><span class="err">配置文件，然后将参数给</span><span class="n">ServletConfig</span><span class="err">和</span><span class="n">ServletContext</span>
<span class="err">然后就不会再读了。所以修改配置文件之后要重新部署</span>
</pre></div>


<ul>
<li>ServletContext问题</li>
</ul>
<div class="hlcode"><pre><span class="n">ServletContext</span><span class="err">针对整个</span><span class="n">Web</span><span class="err">应用，在</span><span class="n">ServeletConfig</span><span class="err">之前创建，个人猜测，然后读取</span><span class="n">web</span><span class="o">.</span><span class="na">xml</span><span class="err">中的键值对</span>
<span class="o">&lt;</span><span class="n">context</span><span class="o">-</span><span class="n">param</span><span class="o">&gt;&lt;/</span><span class="n">context</span><span class="o">-</span><span class="n">param</span><span class="o">&gt;</span><span class="err">在这里配置的参数，这个是</span><span class="o">&lt;</span><span class="n">web</span><span class="o">-</span><span class="n">app</span><span class="o">&gt;</span><span class="err">的下面一层，范围大。所以所有</span><span class="n">servlet</span><span class="err">和</span><span class="n">jsp</span><span class="err">都可以获得</span>

<span class="n">serlvet</span><span class="err">和</span><span class="n">jsp</span><span class="err">都通过</span><span class="n">getServletContext</span><span class="o">()</span><span class="err">即可获得</span><span class="n">web</span><span class="o">.</span><span class="na">xml</span><span class="err">中的参数了</span>
</pre></div>


<ul>
<li>ServletContextListener问题</li>
</ul>
<div class="hlcode"><pre><span class="c1">// 如果我想在应用初始化的时候传入一个对象该怎么办？我希望这个对象能够在应用初始化的时候做一些事情，销毁的时候也做一些事情。</span>

<span class="c1">// 1. 创建一个对象，这个对象是你需要在应用初始化的时候传入的一个对象</span>
<span class="c1">// 2. 定义一个context的初始化参数dbType，用来获取指定的数据库类型</span>
<span class="c1">// 3. 创建一个监听者类，实现接口ServletContextListener即可</span>
<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">contextInitialized</span><span class="o">(</span><span class="n">ServletContextEvent</span> <span class="n">sce</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 初始化函数</span>
    <span class="c1">// 这里简单的写一个，我们会从web.xml中获取一个String参数，假设传入一个工厂类，然后返回需要的数据库连接</span>
    <span class="n">ServletContext</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">sce</span><span class="o">.</span><span class="na">getServletContext</span><span class="o">();</span>
    <span class="n">String</span> <span class="n">dbType</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="na">getInitParameter</span><span class="o">(</span><span class="s">&quot;dbType&quot;</span><span class="o">);</span>
    <span class="n">DataBaseMySql</span> <span class="n">db</span> <span class="o">=</span> <span class="n">DbFactory</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">dbType</span><span class="o">);</span>
    <span class="n">sc</span><span class="o">.</span><span class="na">setAttribute</span><span class="o">(</span><span class="s">&quot;db&quot;</span><span class="o">,</span> <span class="n">db</span><span class="o">);</span>
<span class="o">}</span>

<span class="nd">@Override</span>
<span class="kd">public</span> <span class="kt">void</span> <span class="nf">contextDestroyed</span><span class="o">(</span><span class="n">ServletContextEvent</span> <span class="n">sce</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// 销毁函数</span>
<span class="o">}</span>
<span class="c1">// 4. 在web.xml中添加listener</span>
<span class="o">&lt;</span><span class="n">listener</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">listener</span><span class="o">-</span><span class="n">class</span><span class="o">&gt;</span><span class="n">MyListener</span><span class="o">&lt;/</span><span class="n">listener</span><span class="o">-</span><span class="n">class</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">listener</span><span class="o">&gt;</span>

<span class="c1">// 5. 然后写个继承自servlet的测试类测试能否获取即可</span>
</pre></div>


<ul>
<li>HttpSessionBindingListener</li>
</ul>
<div class="hlcode"><pre><span class="c1">// HttpSessionBindingListener和HttpSessionAttributeListener的区别</span>
<span class="c1">// HttpSessionAttributeListener希望会话中增加、删除或替换某种类型的属性能够知道</span>
<span class="c1">// HttpSessionBindingListener让属性本身在增加到一个会话或从会话中被删除时得到通知</span>
</pre></div>


<ul>
<li>属性与参数的区别</li>
</ul>
<div class="hlcode"><pre><span class="c1">// 由于请求是并发的，所以要注意你的上下文属性，可能会被修改</span>
<span class="c1">// 上下文属性的安全应该通过同步上下文才对。不能同步doGet()等方法，因为同步这些方法意味着你的应用一次只能接待一个用户，而且如果有另一个servlet也访问这个属性，就没有办法了。</span>
<span class="c1">// 所以只要同步上下文即可</span>
<span class="kd">synchronized</span><span class="o">(</span><span class="n">getSerlvetConext</span><span class="o">()){</span>
    <span class="c1">// 在这里对属性进行操作</span>
<span class="o">}</span>
</pre></div>


<ul>
<li>安全问题</li>
</ul>
<div class="hlcode"><pre><span class="c1">// 上下文需要安全，session需要安全，</span>
<span class="c1">// 但是我们无法对请求方法进行同步，这样只能阻止一个servlet的访问，不能阻止零另一个servlet，所以我们要在方法内部对这些接口或者对象的实例化成员同步</span>

<span class="c1">// 但是同步代码会增加开销，所以如果代码并不访问受保护的内容，则不需要同步</span>
</pre></div>


<ul>
<li>会话迁移</li>
</ul>
<div class="hlcode"><pre><span class="c1">// 如果在会话迁移的时候需要保存和恢复属性。这个属性是个对象，则这个对象需要实现HttpSessionActivationListener</span>
</pre></div>
  
</div>
    </div>
    <div id="footer">
      <div class="footer-left">
        <p>
        Copyright © 2016 Fang.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.
        Theme by <a href="https://git.coding.net/tankywoo/yasimple_x2.git" target="_blank">YASimple_X2</a>.
        </p>
      </div> <!-- end footer-left -->
      <div class="footer-right">
        <p>Site Generated 2016-08-31 13:16:21</p>
      </div> <!-- end footer-right -->
    </div>
  </body>
</html>